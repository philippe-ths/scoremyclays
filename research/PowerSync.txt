# Recommended Technology Add-Ons

Claude Code, V0 and Vercel already give you AI-assisted coding, UI generation and global hosting. The remaining gaps are a secure, real-time data layer, type-safe API glue and an elastically scalable database. Combining the tools below covers those needs while staying 100% serverless and edge-optimised.

## 1. Supabase — “backend-in-a-box” for Postgres

| Functional need | Supabase feature | Benefit |
|---|---|---|
| User authentication | Email / social / passwordless auth with Row-Level Security[1][2] | Zero-config auth, fine-grained data access in SQL |
| Realtime UI (chats, live dashboards) | Broadcast, Presence & Postgres-Changes channels over WebSockets[3][4][5] | Sub-200 ms push updates without extra brokers |
| Serverless business logic | Deno Edge Functions (global) & Background Tasks[6][7] | Run secure TypeScript at the edge, schedule jobs |
| File uploads / images | S3-compatible Storage with CDN & on-the-fly transforms[8] | Serve media from the same origin, no extra bucket |
| Webhooks / triggers | Database Webhooks & pg_cron[1][9] | Integrate external SaaS, run scheduled jobs in SQL |

Supabase slots naturally into Vercel; both default to the same edge regions and Supabase’s **`@supabase/supabase-js`** client works in the browser, Node and Vercel Edge Functions.

## 2. tRPC — End-to-end type-safe API layer

tRPC lets your Next.js/V0 frontend call server procedures with full TypeScript inference—no REST or GraphQL boilerplate[10][11][12][13].

-  **Autocompletion across the stack**: changing a server procedure instantly surfaces errors in the client editor.

-  **Zero code-gen**: reduces build times and avoids extra SDK maintenance.

Pair tRPC with **Zod** for input validation to match V0’s default use of Zod schemas.

## 3. Prisma ORM (Edge build) + PlanetScale / Supabase Postgres

| Option | When to choose | Edge compatibility |
|---|---|---|
| **Prisma + Supabase Postgres** | You prefer Postgres + vector search | Prisma Postgres driver is fully edge-capable on Vercel[14][15] |
| **Prisma + PlanetScale (MySQL)** | You need unlimited branching & zero-downtime schema merges[16][17][18][19] | PlanetScale serverless driver supported in Prisma Edge build[14][20] |

Prisma gives you a mature data-modelling layer, migrations and optimised queries, while its new **Edge build** keeps cold-start times low inside Vercel Edge Functions[20][21].

## 4. Auxiliary Picks

| Area | Tool | Rationale |
|---|---|---|
| State/query caching | **TanStack Query** | Automatic stale-while-revalidate around tRPC calls |
| Styling | **Tailwind CSS** (already generated by V0) | Utility classes align with V0 component output |
| Testing | **Playwright** | Runs headless in Vercel CI; good for AI-generated UIs |
| Analytics / logging | **Vercel Analytics + Supabase Log Drains**[1] | Unified performance & database insights |
| Observability for functions | **Sentry Deno SDK** inside Supabase Edge Functions[6] | Trace edge calls end-to-end |

## End-to-End Workflow

1. **Generate UI** in V0 ➜ React + Tailwind components.  
2. **Claude Code** refactors, writes tRPC procedures and Prisma models.  
3. **Supabase** hosts Postgres, auth, storage and real-time messaging.  
4. **Prisma Edge Client** connects from Vercel Edge Functions (or Supabase Functions) to the database.  
5. **tRPC** exposes server logic to the V0 React components with instant type sharing.  
6. **Vercel** builds & deploys; edge runtime keeps latency < 50 ms for global users.

This stack keeps everything **serverless, typesafe and AI-assisted**, matching the functional spec without introducing heavyweight DevOps overhead.
